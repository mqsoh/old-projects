# Bootstrap

I'll need one module for the game code and another for unit tests.

###### file:src/game.lfe
```{.lisp name="file:src/game.lfe"}
(defmodule game
  (export all))

<<Database utility functions.>>
<<Application callbacks.>>
<<Myserver callbacks.>>
<<Routing>>
<<Basic auth middleware.>>
<<Authentication middleware.>>
```

###### file:test/game-unit.lfe
```{.lisp name="file:test/game-unit.lfe"}
(defmodule game-unit
  (export all))

(include-lib "eunit/include/eunit.hrl")

<<Unit test generator.>>
```

All applications in Erlang need an [application resource file][]. The projects
I've seen generated by Erlang tools usually include a lot more in the `.app`,
but none of that is required. However, it might be used in some way that I
don't understand. I don't want to worry about doing things the right way right
now.

The `applications` config parameter is also optional. I'm including it because
it defaults to `[]` even though (according to the man page) all applications
depend on `kernel` and `stdlib`.

[application resource file]: http://www.erlang.org/doc/man/app.html

###### file:ebin/game.app
```{.erlang name="file:ebin/game.app"}
{application, game,
  [{applications, [kernel, stdlib]},
   {env, [{'PORT', 0},
          {'DATABASE_URL', "postgres://localhost:5432/game"}]},
   {mod, {game, []}}]}.
```

If you give a port of `0` to the `gen_tcp` module it resolves to any open port.
Eventually I'll run this game on Heroku which uses the `PORT` and
`DATABASE_URL` in its environment. The `env` parameters given here are
defaults; when deploying to Heroku, the command in the `Procfile` will use the
`-Application Par Val` flags to `erl`, i.e. `-game PORT $PORT -game
DATABASE_URL $DATABASE_URL`.

My game will be both a callback module for the `application` and
[`myserver`](myserver.md) behaviors.



## Bootstrapping the database.

For local development I

- installed PostgreSQL,

    sudo aptitude install postgresql

- removed it from init,

    sudo update-rc.d postgresql remove

- added `bin` to my path (in fish shell),

    set -U fish_user_paths $fish_user_paths /usr/lib/postgresql/9.4/bin

- initialized the database,

    initdb local-database

- ran Postgres as myself, and

    postgres -D local-database -k /tmp

- created the game database.

    createdb -h localhost game

Now the game database is available at `postgresql://localhost:5432/game`. In
some ways its simpler to just use the system daemon, but I find the postgres
permissions irritating and, since I intend to run this on Heroku, it's not
something I'll need to worry about.

To install the `epgsql` library, I ran the following. I need to remember to add
the `-pa deps/*/ebin` when I run the REPL.

    mkdir deps
    cd deps
    git clone https://github.com/epgsql/epgsql.git
    cd epgsql
    rebar compile

**TODO**: Why don't I just use rebar and/or hex? I will. I just like doing
things myself first.

On Heroku, the connection to the database is provided as a DSN in the
`DATABASE_URL` environment variable. This regex will match a postgres DSN with
optional credentials and optional port number.

###### DSN regex.
```{name="DSN regex."}
(?# This could be used with any driver, but since my application only uses
PostgresQL, that's all I'll match.)
postgres://

(?# The username and password are optional, but required as a unit.)
(?|(?<username>[^:]+):(?<password>[^@]+)@)?

(?# The host name is required up until the port number, if provided.)
(?<host>[^:/]+)

(?# The port number is optional.)
(?|:(?<port>[^/]+))?

(?# A '/' will mark the start of the database name.)
/

(?# The rest of the string is the database name and is required.)
(?<db>.+)
```

Here's a function to use that pattern to connect to a database. There's four
possibilities:

1. credentials and port provided,
1. credentials provided and port omitted,
1. credentials omitted and port provided, and
1. both credentials and port omitted.

The `dsn regex` is output inside an iolist to accomodate the literate
programming style (`<<DSN regex.>>` below). The `'extended` option is to
accomodate the comments in the regex. I learned that `epgsql:connect` takes a
proplist with all the settings from checking [the source code][]; the
documentation makes it seem like it needs some as function arguments and others
as options.

[the source code]: https://github.com/epgsql/epgsql/blob/f1a095c1e878bba385838989b330b409310fb8ff/src/epgsql.erl#L66-L70

###### Database utility functions.
```{.lisp name="Database utility functions."}
(defun dsn-params [dsn]
  (let* ((pattern (list
                    "<<DSN regex.>>"
                  ))
         ((tuple 'match (list _all username password host port dbname))
          (re:run dsn pattern '(extended #(capture all list)))))

    (++ (list (tuple 'host host)
              (tuple 'port (case port ("" 5432)
                                      (_ (erlang:list_to_integer port))))
              (tuple 'database dbname))

        (case (tuple username password)
          ((tuple "" "") '())
          (_ (list (tuple 'username username)
                   (tuple 'password password)))))))

(defun connect-to-database [dsn]
  (let (((tuple 'ok dbconn) (epgsql:connect (dsn-params dsn))))
    dbconn))

(defun configured-database-connection []
  (let* (((tuple 'ok dsn) (application:get_env (MODULE) 'DATABASE_URL)))
    (connect-to-database dsn)))
```

I'll need to be able to rebuild the schema from scratch and destroy an existing
schema. I don't know what the schema will be because I haven't designed the
game yet so these functions will stub out that behavior so that I can add it in
as needed.

They should provide a context with a database connection (called `dbconn`) and
close the connection when they're done. I will need:

- destroy-schema
- create-schema
- rebuild-schema

The `rebuild-schema` function will be used in development to update changes
with minimal fuss.

> When creating new tables, I need to use the `game` schema, i.e. `create table
> game.user ...`.

```{.lisp name="Database utility functions."}
(defun create-schema [dbconn]
  (let* ((sql (list
                "CREATE SCHEMA game;"
                "<<Initial SQL.>>"
              ))
         (single-statement (string:join sql ""))
         (responses (epgsql:squery dbconn single-statement)))
    (lfe_io:format "~p~n" (list responses))))

(defun destroy-schema [dbconn]
  (epgsql:squery dbconn "DROP SCHEMA IF EXISTS game CASCADE"))

(defun rebuild-schema [dbconn]
  (destroy-schema dbconn)
  (create-schema dbconn))
```



## Bootstrapping the unit tests.

Some of the unit tests will need to test database side effects. When running
unit tests on Django, it will create and initialize a test database before
tests are run and tear it down at the end. I want to do the same thing.

**TODO**: Right now I'll just use the configured database without creating a
special test database. I don't feel like munging the database name (to append
`_test`) or figuring out a way to configure the SQL statements. The database is
created manually (enumerated in the previous section) so something non-trivial
would need to be done.

Doing this with `eunit` is not straightforward. With eunit, any function that
ends in `_test_` is a 'generator'. The structure of the return value can define
many things, among them 'fixtures'. The fixture then defines the list of
'instantiators'. This terminology was confusing for me. Let's look at it from
the inside out.

I was already familiar with the `?assertEquals` macro (in LFE, this is just
`assertEquals`). These don't work with instantiators. Instantiators need to
return a list of the assertions that start with an underscore, i.e.
`?_assertEquals`. The only difference is that [the leading underscore versions
return closures][] and are executed later. When I create unit tests, they will
be functions that return these assertions.

[the leading underscore versions return closures]: https://github.com/erlang/otp/blob/172e812c491680fbb175f56f7604d4098cdc9de4/lib/eunit/include/eunit.hrl#L160

This list of assertions can nest, so this is a valid return value for an
instantiator.

    (list (_assertEqual 1 1)
          (list (_assertEqual 1 1)
                (_assertEqual 1 1)))

One example of a fixture is: `(tuple 'setup setup cleanup instantiator)`. For
my game unit tests, the `instantiator` will return a list of assertions but it
does this by calling the functions defined in this document. The unit test
functions are nested instantiators. Since the whole point of this is to give a
connection to a prepared database to my test functions, we need to call each
test function and pass the connection (the `lists:map` below).

###### Unit test generator.
```{.lisp name="Unit test generator."}
(defun setup []
  (application:start 'game)
  (let ((dbconn (game:configured-database-connection)))
    (game:create-schema dbconn)
    dbconn))

(defun cleanup [dbconn]
  (game:destroy-schema dbconn)
  (epgsql:close dbconn))

(defun instantiator [dbconn]
  (lists:map (lambda [test]
              (io:format "Calling ~p~n" (list test))
              (funcall test dbconn))
             (list
              <<Unit tests.>>
              )))

(defun game_test_ []
  (tuple 'setup
         (fun setup 0)
         (fun cleanup 1)
         (fun instantiator 1)))
```

Now each individual unit test will have the following form:

    (lambda [dbconn]
      (_assertEqual 1 1))

...or...

    (lambda [dbconn]
      (list (_assertEqual 1 1)
            (_assertEqual 1 1)))

This follows the [some_tricky_test_][] example in the Learn You Some Erlang
book. Their explanation might be better.

[some_tricky_test_]: http://learnyousomeerlang.com/eunit#fixtures



# Application callbacks.

The man page for the application module makes it seem like you need a lot more
functions for the application behavior. However, when I ran a test `start/2`
and `stop/1` were the only missing functions indicated by the compiler. I'll
opt for the bare minimum.

Both functions are trivial; `start/2` only initializes the `myserver` behavior
and `stop/1` does nothing. However, in the future, I might add a way to tear
down acceptor processes in `myserver`. If I do that, I would add logic here to
trigger it.

```{.lisp name="Application callbacks."}
(defun start [_type _args]
  (myserver:start-link (MODULE) 'game))

(defun stop [_] 'ok)
```



# Myserver callbacks.



## Server initialization.

The `myserver behavior` uses `server-init` to configure the server with the
port number and the number of acceptors in the pool.

###### Myserver callbacks.
```{.lisp name="Myserver callbacks."}
(defun server-init
  (['game]
    (lfe_io:format "game:server-init~n" '())
    (let (((tuple 'ok port-number) (application:get_env (MODULE) 'PORT))
          (number-of-acceptors 4))
      (lfe_io:format "game:server-init returning ~p~n" (list (tuple 'ok port-number number-of-acceptors)))
      (tuple 'ok port-number number-of-acceptors))))
```

The four acceptor processes is arbitrary. It represents the number of
concurrent requests. I think, even on a Heroku 1x dyno, that more can be
handled. I'll have to test it at some point.

**TODO**: Run a test for the number of acceptors that can be handled by a
Heroku 1x dyno.



## Initialize the acceptors.

I'm going to give one database connection to each acceptor. This is simple to
do with the `acceptor-init` callback. The return value from this function is
the acceptor's state. With this game it will just be the database connection
and nothing else.

> Note: The database connection is the 'acceptor state' given to `handle/3`.

###### Myserver callbacks.
```{.lisp name="Myserver callbacks."}
(defun acceptor-init
  (['game port-number 4]
    (lfe_io:format "Acceptor ~p running on ~p.~n" (list (self) port-number))
    (tuple 'ok (configured-database-connection))))
```



## Handle requests.

Every request is going to need to use [the HTTP request parser described in
parsing_http_requests.md](parsing_http_requests.md).

###### Myserver callbacks.
```{.lisp name="Myserver callbacks."}
(defun handle
  (['game socket dbconn]
    (let ((request (http-request:run socket)))
      <<Route the request>>
      (tuple 'close dbconn))))
```

The `(tuple 'close dbconn)` doesn't close the database connection. It tells
myserver to close the request; `dbconn` is the updated state and is passed to
the next handle call.

Routing is described below.



# Routing

Now I need to decide how to handle routing. The initial idea I had was that all
game/server features should be considered middleware -- even what are called
'views' in some frameworks. I tried to set up generic middleware for all types
of requests. But wait a minute! Public URLs, like the home page and user
creation endpoints, need different sets of middleware since I intend to have
middleware to handle user authentication.

I also thought it would be cool to use pattern matching for routes, i.e.

    (case request
     ([(map 'method 'GET 'uri "/")]
      ...)
     ([(map 'method 'POST 'uri "/create-user")]
      ...))

However, any time a URI is parameterized (as in `GET /user/1234`) we can't use
pattern matching for that route. This is what I'll do instead.

    (list
     (tuple (map 'method 'GET
                 'uri "/")
            (list (fun view-home 1)))

     (tuple (map 'method 'GET
                 'uri "/user/profile")
            (++ private-middleware
                (list (fun view-profile 1))))

     (tuple (map 'method 'GET
                 'uri-like "^/user/(\\d+)$")
            (list (fun get-user 1)))

     (tuple (map 'method 'POST
                 'uri-like #("^/user/(\\d+)$" (user-id)))
            (++ private-middleware
                (list (fun update-user 1))))

A route is a tuple of a map (to be compared to the request) and a list of
middleware functions. The example shows how to use list concatenation to
abstract sets of middleware (`private-middleware`). When the route is evaluated
all keys will be tested for equality -- except for `'uri-like`. This will use
regex to evaluate the `'uri`.

If the `'uri-like` value is a string, I'll only check if it matches the
request's URI. If a tuple is provided with the pattern and a list of capture
group names, I'll augment the request object with a `'uri-params` map with the
captured groups, i.e. `#("/user/(\\d+)" (user_id))`.

(I can't use named subpatterns here becuase Erlang's `re` module doesn't return
the name of the group. The only relevent result for [a search on this issue][]
is one of the devs saying that it could be added if there's ["general need"][].
I don't know how general need is demonstrated (I consider this a classic
dodge), so I'll just work around the problem with this tuple spec.)

[a search on this issue]: https://duckduckgo.com/?q=erlang+capture+named+subpatterns
["general need"]: http://www1.erlang.org/pipermail/erlang-questions/2008-October/038906.html

I can now establish the signature and spec of the `route 1` function. Since
routing can potentially update the request object:

    (route routing-spec request) -> (tuple request middleware)

    routing-spec = (list route ...)

    route = (tuple request-spec (list middleware-function ...))

    request-spec = (map)

    middleware-function = fun/1

## Tests

Here are some tests for the routing middleware. The lists of middleware are
just atoms in these tests to make it easier to read.

This tests the basic matching. The correct route is the middle one, `/about`.

```{.lisp name="Unit tests."}
(lambda [_]
  (let ((request (map 'method 'GET
                      'uri "/about"
                      'version #(1 1)
                      'get (map)
                      'headers (map)))

        (routes (list (tuple (map 'method 'GET 'uri "/")
                             (list 'wrong))
                      (tuple (map 'method 'GET 'uri "/about")
                             (list 'right))
                      (tuple (map)
                             (list 'fallback)))))

    (_assertEqual (tuple request (list 'right))
                  (game:route routes request))))
```

This tests the fallback behavior. An empty map matches any sort of request.

```{.lisp name="Unit tests."}
(lambda [_]
  (let ((request (map 'method 'GET
                      'uri "/burp"
                      'version #(1 1)
                      'get (map)
                      'headers (map)))

        (routes (list (tuple (map 'uri "/poot")
                             (list 'wrong))
                      (tuple (map)
                             (list 'fallback)))))

    (_assertEqual (tuple request (list 'fallback))
                  (game:route routes request))))
```

Check the simple `'uri-like` case: only a pattern is provided and the request
is not augmented with any parameters.

```{.lisp name="Unit tests."}
(lambda [_]
  (let ((request (map 'method 'GET
                      'uri "/user/1234"
                      'version #(1 1)
                      'get (map)
                      'headers (map)))
        (routes (list (tuple (map 'uri "/about")
                             (list 'wrong))
                      (tuple (map 'uri-like "^/user/(\\d+)$")
                             (list 'matched))
                      (tuple (map) (list 'fallback)))))

    (_assertEqual (tuple request (list 'matched))
                  (game:route routes request))))
```

Finally, test that `'uri-params` is added to the request.

```{.lisp name="Unit tests."}
(lambda [_]
  (let ((request (map 'method 'GET
                      'uri "/user/1234/update"
                      'version #(1 1)
                      'get (map)
                      'headers (map)))

        (routes (list (tuple (map 'uri "/wrong")
                             (list 'wrong))
                      (tuple (map 'uri-like #("^/user/(\\d+)/([^/]+)$" (user-id action)))
                             (list 'right))
                      (tuple (map)
                             (list 'fallback)))))

    (_assertEqual (tuple (maps:put 'uri-params
                                   (map 'user-id "1234" 'action "update")
                                   request)
                         (list 'right))
                  (game:route routes request))))
```

## Implementation

I need to know if one map is a subset of another. This is used to compare the
route with the request.

```{.lisp name="Unit tests."}
(lambda [_]
  (list (_assertEqual 'false (game:subset? (map 'a 'A) (map 'b 'B)))
        (_assertEqual 'false (game:subset? (map 'a 'A 'b 'B) (map 'b 'B)))
        (_assertEqual 'false (game:subset? (map 'a 'A ) (map 'a 'not-A)))
        (_assertEqual 'true (game:subset? (map 'b 'B) (map 'a 'A 'b 'B)))
        (_assertEqual 'true (game:subset? (map) (map 'a 'A 'b 'B)))))
```

```{.lisp name="Routing"}
(defun subset? [a b]
  (subset? a b (maps:keys a)))

(defun subset?
  ([_ _ (list)]
    'true)

  ([a b (cons key rest)]
    (case (maps:find key b)
          ('error
            'false)
          ((tuple 'ok b-value)
            (case (== b-value (maps:get key a))
              ('false
                'false)
              ('true
                (subset? a b rest)))))))
```

Because the `'uri-like` value in a route is special and can't be compared to
the request, I also need to `maps:remove` it out of the request spec before
comparing it to the request.

```{.lisp name="Routing"}
(defun route
  ([(list) request]
    (tuple request (list)))

  ([(cons (tuple request-spec middleware-functions) rest) request]
    (case (subset? (maps:remove 'uri-like request-spec)
                   request)
          ('false
            (route rest request))

          ('true
            (case (maps:get 'uri-like request-spec 'nil)
                  ('nil
                    (tuple request middleware-functions))

                  ((tuple pattern capture-group-names)
                    (case (re:run (map-get request 'uri) pattern '(#(capture all list)))
                          ('nomatch
                            (route rest request))

                          ((tuple 'match (cons _full groups))
                            (tuple (map-set request
                                            'uri-params
                                            (maps:from_list (lists:zip capture-group-names groups)))
                                    middleware-functions))))

                  (pattern
                    (case (re:run (map-get request 'uri) pattern)
                          ('nomatch
                            (route rest request))

                          ((tuple 'match _)
                            (tuple request middleware-functions)))))))))
```

That's a mouthfull...

**TODO**: Refactor this or don't.

Now I can bootstrap the application routes and provide a fallback 404 handler.

###### Route the request
```{.lisp name="Route the request"}
(let* ((routes (list
                  <<Routes>>

                  ; 404 handler.
                  (tuple (map)
                         (list (match-lambda ([(tuple _pass _dbconn socket _request)]
                                              (gen_tcp:send socket (list
                                                #B("HTTP/1.1 404 Not Found\r\n")
                                                #B("Content-Type: text/plain\r\n")
                                                #B("\r\n")
                                                #B("Page not found.")))))))))

        ((tuple routed-request middleware) (game:route routes request)))

  ; Feed the middleware.
  (lists:foldl (lambda [fun state]
                (funcall fun state))
               (tuple 'pass dbconn socket routed-request)
               middleware))
```

**TODO**: I need a way of testing the views...



# Middleware.

I messed around with Clojure a while ago and I was really impressed by
[ring][]. Sessions, cookies, and file uploads are implemented as middleware. I
want to do the same thing.

[ring]: https://github.com/ring-clojure/ring

I also came across Scott Wlaschin's presentation of [Railway Oriented
Programming][]. My middleware will be railway oriented and will accept one
argument which is a tuple of the atom `'pass` or `'fail`, the acceptor state
(which in this application is the database connection), the accepted socket,
and a map representing the current request state. For example:

    (tuple 'pass socket dbconn (map 'uri "/foobar"))

[Railway Oriented Programming]: http://fsharpforfunandprofit.com/rop/

Most middleware, when given `'fail` will return the input unchanged. However,
middleware implementing a logger or 404 page would probably have program logic
around a failure.

All middleware is free to write to the socket.



## Basic auth middleware.

The first middleware I will write will be one to require [basic auth][]
credentials. If the `Authenticate` header isn't provided, it will respond with
a `401 Not authorized`. If the header is provided, the request object will be
updated with the credentials provided. Other middleware will provided
*authorization*.

[basic auth]: https://en.wikipedia.org/wiki/Basic_access_authentication

```{.lisp name="Basic auth middleware."}
(defun basic-auth
  ; Fail track; bypass middleware.
  ([(= (tuple 'fail _ _ _) state)]
    state)

  ([(tuple 'pass acceptor-state socket request)]
    (case (maps:get 'Authorization (map-get request 'headers) 'nil)
      ; Fail track; request credentials.
      ('nil
        (gen_tcp:send socket (list
          #B("HTTP/1.1 401 Unauthorized\r\n")
          #B("WWW-Authenticate: Basic realm=\"Mason's Game\"\r\n")
          #B("\r\n")))
        (tuple 'fail acceptor-state socket request))

      ; Pass track; add credentials to the request map.
      ((binary #\B #\a #\s #\i #\c #\  (encoded binary))
        (let* ((decoded (base64:decode encoded))
               ((list username password) (re:split decoded ":" '(#(return list))))
               (credentials (map 'username username 'password password))
               (updated-request (maps:put 'basic-auth credentials request)))
          (tuple 'pass acceptor-state socket updated-request))))))
```

I wasn't exactly sure what the middleware functions would look like, so I wrote
this function (and tested it manually) without writing a unit test. Let me do
that now.

One of the side effects of this middleware is that it writes to the socket to
request user credentials. Using the pair of mock functions in `myserver`
(`myserver:make-mock-server` and `myserver:destroy-mock-server`), I can test
the side effects of the basic auth middleware.

###### Unit tests.
```{.lisp name="Unit tests."}
(lambda [_]
  "Tests bypass of the middleware if any previous middleware fails."
  (let* ((input (tuple 'fail 'anything 'anything 'anything))
         (expected input)
         (actual (game:basic-auth input)))
    (_assertEqual expected actual)))

(lambda [_]
  "Tests that the client receives a 401."
  (let* (((= mock-server (tuple _ accepted-socket _)) (myserver:make-mock-server))
         (mock-request (map 'headers (map)))
         (input (tuple 'pass 'acceptor-state accepted-socket mock-request))
         (expected-return (tuple 'fail 'acceptor-state accepted-socket mock-request))
         (expected-side-effect #B("HTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Basic realm=\"Mason's Game\"\r\n\r\n")))
    (list (_assertEqual expected-return (game:basic-auth input))
          (_assertEqual expected-side-effect (myserver:destroy-mock-server mock-server)))))

(lambda [_]
  "Tests that the request object is updated with user credentials."
  (let* (((= mock-server (tuple _ accepted-socket _)) (myserver:make-mock-server))
         (mock-request (map 'headers (map 'Authorization #B("Basic c2FsbHk6c2VjcmV0"))))
         (input (tuple 'pass 'acceptor-state accepted-socket mock-request))
         (expected-return (tuple 'pass
                                 'acceptor-state
                                 accepted-socket
                                 (maps:put 'basic-auth
                                           (map 'username "sally"
                                                'password "secret")
                                           mock-request))))
    (myserver:destroy-mock-server mock-server)
    (_assertEqual expected-return (game:basic-auth input))))
```



## Authentication middleware.

I want as little ceremony around user creation as possible, so if someone
provides basic auth credentials and the user doesn't exist, I'll create a new
user with those credentials. Subsequent requests must use the same credentials.

To manage passwords, we'll need the following functions.

```{.lisp name="Authentication middleware."}
<<Create a salt.>>
<<Create a storable hash with a salt and plain text password.>>
<<Validate a stored password given plain text.>>
<<User CRUD.>>
<<Implement the authenticate middleware.>>
```

### Create a salt.

```{.lisp name="Create a salt."}
(defun create-salt []
  "Returns 16 random, base64-encoded characters."
  (base64:encode_to_string (crypto:strong_rand_bytes 12)))
```

**TODO**: I'm pretty sure that in the Buckets of Sockets chapter of Learn You
Some Erlang the author did something in the acceptor process to seed the random
number generator. Look this up and see if I need it for the use of
`crypto:strong_rand_bytes` here.

The test is very simple since I only need to ensure that it's 16 characters
since the assumption is used later.

```{.lisp name="Unit tests."}
(lambda [_]
  (_assertEqual 16 (string:len (game:create-salt))))
```

### Create a storable hash with a salt and plain text password.

The crypto module doesn't have PBKDF2 or bcrypt and the libraries I looked at
don't seem to have been standardized. For instance, the Erlang implementation
of PBKDF2 linked from the Wikipedia article is from someone that simply
isolated it from CouchDB's code base. The place where it was forked doesn't
exist anymore; did CouchDB make any changes? Then there are other people that
forked that library. They made changes that, to me, are superficial -- but are
they? Anyway, this is starting to irritate me and I'm starting to not want to
write code so I'm skipping it for now. For now, I'll just store hashed
passwords as salted HMAC SHA512, base64 encoded.

**TODO**: Use PBKDF2 or bcrypt after evaluating the available libraries.

I want to store passwords and salts in the database with the same field. In the
web frameworks I've used in the past, they store something like
`<algorithm>$<salt>$<hash>`. I'm not supporting multiple algorithms and if I
know the length of the salt, I don't see a need to store a separator character.
I'll store `<salt><hash>`.

```{.lisp name="Create a storable hash with a salt and plain text password."}
(defun hash-password [salt plain-text]
  "Returns \"<salt><hash>\"."
  (let* ((hmac (crypto:hmac 'sha512 "TODO" (list salt plain-text)))
         (encoded (base64:encode_to_string hmac)))
    (string:join (list salt encoded) "")))
```

**TODO**: The `TODO` in the previous code block needs to use a site secret as
the key to the hmac function.

### Validate a stored password given plain text.

To compare passwords, I want to be able to give a stored value from the
database and the given password and just find out if they match. To do that,
I'll also have to split the stored value into the salt and password so that the
salt can be used to re-hash the plain text.

```{.lisp name="Validate a stored password given plain text."}
(defun passwords-match? [stored-password plain-text]
  (let ((salt (string:substr stored-password 1 16)))

    (string:equal stored-password
                  (hash-password salt plain-text))))
```

Test that a password generated by this system can be validated by this system.

```{.lisp name="Unit tests."}
(lambda [_]
  (list
    (_assertEqual
      'true
      (game:passwords-match? (game:hash-password "dumb-salt" "secret")
                             "secret"))
    (_assertEqual
      'false
      (game:passwords-match? (game:hash-password "dumb-salt" "secret")
                             "not right"))))
```

### User CRUD.

We need a user table. The password length is determined by the output of the
`hash-password` function.

If the user doesn't exist, this is a small abstraction to generate a new
storable password.










This first tests the fail track, that it correctly bypasses failures in
previous middleware functions.

###### Authentication unit tests.
```{.lisp name="Authentication unit tests."}
(lambda [_dbconn]
  (let* ((input (tuple 'fail 'anything 'anything 'anything))
         (expected input)
         (actual (game:authentication input)))
    (assertEqual expected actual)))
```

This tests the successful case whereby a new user is created and re-authed.

```{.lisp name="Authentication unit tests."}
(lambda [dbconn]
  (let* (((= mock-server (tuple _ accepted-socket _)) (myserver:make-mock-server))
         (mock-request (map 'basic-auth (map 'username "sally" 'password "secret")))
         (input (tuple 'pass accepted-socket dbconn mock-request))
         (expected (tuple 'pass dbconn (maps:put 'authentication "sally" mock-request))))

    ; Assert that the user doesn't exist yet.
    (let (((tuple 'ok _headers rows) (epgsql:squery dbconn "select * from game.user where name = $1" '("sally"))))
        (assertEqual 0 (erlang:length rows)))

    ; Assert that a new user is created.
    (assertEqual expected (game:authentication input))
    (let (((tuple 'ok _headers rows) (epgsql:squery dbconn "select * from game.user where name = $1" '("sally"))))
        (assertEqual 1 (erlang:length rows)))

    ; Assert that this user can be reauthenticated.
    (assertEqual expected (game:authentication input))
    (let (((tuple 'ok _headers rows) (epgsql:squery dbconn "select * from game.user where name = $1" '("sally"))))
        (assertEqual 1 (erlang:length rows)))))
```

When authentication fails, the credentials should be requested again.

```{.lisp name="Authentication unit tests."}
(lambda [dbconn]
  (let* (((= mock-server (tuple _ accepted-socket _)) (myserver:make-mock-server))
         (mock-request (map 'basic-auth (map 'username "authentication-failed" 'password "Incorrect password.")))
         (input (tuple 'pass accepted-socket dbconn mock-request))
         ((tuple 'ok 1) (epgsql:equery "insert into game.user (name, password) values ($1, $2)"
                                       (list "authentication-failed"
                                             (game:make-storable-password "Correct password."))))
         (expected (tuple 'fail accepted-socket dbconn mock-request))
         (actual (game:authentication input))
         (client-data (myserver:destroy-mock-server mock-server)))

    (assertEqual expected actual)
    (assertEqual #B("HTTP/1.1 401 Unauthorized\r\n"
                    "WWW-Authenticate: Basic realm=\"Mason's Game\"\r\n"
                    "\r\n")
                 client-data)))
```
This is the occasion for my first database table. The password character length
is the result of the hashing method enumerated below.

###### Initial SQL.
```{.sql name="Initial SQL."}
CREATE TABLE game.user (
  name VARCHAR(100) NOT NULL,
  password VARCHAR(104) NOT NULL
);
```

