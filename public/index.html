<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		
		
		<title>Sample Three.js</title>
		<style>
			#container {
				background: #000;
				width: 100%;
				height: 100%;
			}
			
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}
			
            #info {
				color:#fff;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
				z-index:100;
				
            }
			
		</style>
	</head>
	<body>

		<div id="container">


		</div>

	</body>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	<script src="js/Three.js"></script>
	<script src="js/array.js"></script>

	<script type="text/javascript">

	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var mouseX = 0, mouseY = 0;

	var renderer = new THREE.WebGLRenderer();
	
	// set the scene size
	var WIDTH = windowHalfX*2,
	    HEIGHT = windowHalfY*2;

	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = WIDTH / HEIGHT,
	    NEAR = 0.1,
	    FAR = 10000;

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#container');

	// create a WebGL renderer, camera
	// and a scene
	
	
	//var camera = new THREE.Camera( VIEW_ANGLE, window.innerWidth / window.innerHeight, 1, 3000 );
	var camera = new THREE.PerspectiveCamera(  VIEW_ANGLE,
	                                ASPECT,
	                                NEAR,
	                                FAR  );
	var scene = new THREE.Scene();
	//scene.fog = new THREE.FogExp2( 0x000000, 0.001 );

	// the camera starts at 0,0,0 so pull it back
	camera.position.z = 300;

	// start the renderer
	renderer.setSize(WIDTH, HEIGHT);
	
	
	
	init();
	setInterval( loop, 1000 / 60 );
	
	
	function init() {

		// attach the render-supplied DOM element
		$container.append(renderer.domElement);

		// create the sphere's material
		var sphereMaterial = new THREE.MeshLambertMaterial(
		{
			color: 0xFFFF00
		});

		// set up the sphere vars
		var radius = 5, segments = 10, rings = 10;

		// create a new mesh with sphere geometry -
		// we will cover the sphereMaterial next!
		var sphere = new THREE.Mesh(
		   new THREE.SphereGeometry(radius, segments, rings),
		   sphereMaterial);

		// add the sphere to the scene
		scene.add(sphere);


		for(var i = 0; i < exo_array.length; i++) {

		var p = exo_array[i];

		var col;
			//col = '#ffffff';
		if (p.temp > 6150)
            col = '0x19bce5'
        else if (p.temp > 10000)
            col = '0x01f9f9'
        else if (p.temp > 5900)
            col = '0x00fb44'
        else if (p.temp > 5700)
            col = '0x97fc02'
        else if (p.temp > 5485)
            col = '0xfc9701'
        else if (p.temp > 4900)
            col = '0xfb5c01'
        else
            col = '0xcf4626'

			
			sphereMaterial = new THREE.MeshLambertMaterial(
			{
				color: col
			});
			
			console.log(col);
			
			x = (p.dist * Math.cos(p.dec)) * Math.cos(p.ra)
			y = (p.dist * Math.cos(p.dec)) * Math.sin(p.ra)
			z = p.dist * Math.sin(p.dec)
			
			radius = p.mass / 3
			
			var sph = new THREE.Mesh(
				new THREE.SphereGeometry(radius * Math.random() + .5, segments, rings),
					sphereMaterial);
			sph.position.set(x, y, z)
			scene.add(sph)
			
		}
		
		
		// and the camera
		scene.add(camera);

		// create a point light
		var pointLight = new THREE.PointLight( 0xFFFFFF );

		// set its position
		pointLight.position.x = 10;
		pointLight.position.y = 50;
		pointLight.position.z = 130;

		var pointLight2 = new THREE.PointLight( 0xFFFFFF );

		// set its position
		pointLight2.position.x = -10;
		pointLight2.position.y = -50;
		pointLight2.position.z = -130;

		// add to the scene
		scene.add(pointLight);
		scene.add(pointLight2);

		// draw!
		//renderer.render(scene, camera);
			
		//document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		//document.addEventListener( 'touchstart', onDocumentTouchStart, false );
		//document.addEventListener( 'touchmove', onDocumentTouchMove, false );
	}
	
	
	function onDocumentMouseMove( event ) {
		mouseX = event.clientX - windowHalfX;
		mouseY = event.clientY - windowHalfY;
	}

	function onDocumentTouchStart( event ) {
		if ( event.touches.length == 1 ) {
			event.preventDefault();
			mouseX = event.touches[ 0 ].pageX - windowHalfX;
			mouseY = event.touches[ 0 ].pageY - windowHalfY;
		}
	}

	function onDocumentTouchMove( event ) {
		if ( event.touches.length == 1 ) {
			event.preventDefault();
			mouseX = event.touches[ 0 ].pageX - windowHalfX;
			mouseY = event.touches[ 0 ].pageY - windowHalfY;
		}
	}	


	
	var theta = 0;

	function loop() {
		var time = new Date().getTime() * 0.00005;
		
		//camera.position.x += ( mouseX - camera.position.x ) * 0.05;
		//camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

		//theta = ( mouseX - camera.position.x ) * 0.5
		//phi = ( - mouseY - camera.position.y ) * 0.5;

		var phi = Math.min( 180, Math.max( 0, phi ) );

		radius = 400;
		
		
		theta += 2;

		camera.position.x = radius * Math.sin( theta * Math.PI / 360 );
		camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
		camera.position.z = radius * Math.cos( theta * Math.PI / 360 );
		camera.lookAt( scene.position );

		renderer.render( scene, camera );

			

		
		
/*		
		camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
		camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
		camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
		camera.updateMatrix();		

		controls = new THREE.TrackballControls( camera );
        controls.target.set( 0, 0, 0 )
		
		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;

		controls.noZoom = false;
		controls.noPan = false;

		controls.staticMoving = false;
		controls.dynamicDampingFactor = 0.15;

		controls.keys = [ 65, 83, 68 ];
		
		controls.update();
/*				
		for( i = 0; i < scene.objects.length; i++ ) {
		
			scene.objects[i].rotation.y = time * ( i < 4 ? i+1 : - (i+1) );
			
		}

		for( i = 0; i < materials.length; i++ ) {
			
			color = parameters[i][0];
			
			h = ( 360 * ( color[0] + time ) % 360 ) / 360;
			materials[i].color.setHSV( h, color[1], color[2] );
			
		}
*/				
		//renderer.render( scene, camera );
		//renderer.render( scene, camera );

	}
	
	
	
	/**
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   Number  h       The hue
	 * @param   Number  s       The saturation
	 * @param   Number  l       The lightness
	 * @return  Array           The RGB representation
	 */
	function hslToRgb(h, s, l){
		var r, g, b;

		if(s == 0){
			r = g = b = l; // achromatic
		}else{
			function hue2rgb(p, q, t){
				if(t < 0) t += 1;
				if(t > 1) t -= 1;
				if(t < 1/6) return p + (q - p) * 6 * t;
				if(t < 1/2) return q;
				if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
				return p;
			}

			var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			var p = 2 * l - q;
			r = hue2rgb(p, q, h + 1/3);
			g = hue2rgb(p, q, h);
			b = hue2rgb(p, q, h - 1/3);
		}

		return [r * 255, g * 255, b * 255];
	}	
	
	
	</script>
</html>
